import { v4 } from 'uuid';
import * as fs from 'fs/promises';
import path from 'path';

import { error } from '../utils';
import { WORKERS_PATH } from '../consts';
import { GoOptions, ThreadyInfo } from '../types';

const createWorkerFile = async (
    script: Function,
    { debug = false, imports = [], info }: Partial<GoOptions> & Partial<{ info: ThreadyInfo }> = {}
) => {
    const fileName = v4() + '.cjs';
    const stringified = script.toString();

    const string = `// Workerfile generated by Thready
const { workerData, parentPort, isMainThread, threadId } = require('worker_threads');
${imports.map(({ name, from }) => `const ${name} = require('${from}')\n`)}
const script = ${stringified};
${debug ? `\nconsole.log({ isMainThread, threadId, activeThreads: ${info?.active}, waitingThreads: ${info?.waiting} })\n` : ''}
const { args } = workerData;

const runScript = async () => {
    try {
        data = await script(...args)
    } catch (error) {
        throw new Error(\`\${error}\`);
    };

    if (!data) parentPort.postMessage(true);

    parentPort.postMessage(data);

    process.exit(0);
};

runScript();`;

    try {
        await fs.writeFile(path.join(WORKERS_PATH + `/${fileName}`), string);
    } catch (err) {
        throw new Error(error(`Failed to create worker file! ${err}`));
    }

    return fileName;
};

export const cleanWorkerFile = async (workerFile: string) => {
    return fs.unlink(path.join(WORKERS_PATH + `/${workerFile}`));
};

export default createWorkerFile;
